# Документация для ipv6_sockets.c

## 1. Общее описание

Файл `ipv6_sockets.c` представляет собой пример клиент-серверного приложения, работающего по протоколу TCP через IPv6. Ключевой особенностью этого примера является демонстрация создания и анализа пакетов IPv6 с пользовательским расширенным заголовком — "Опции назначения" (Destination Options).

Приложение может работать в двух режимах:
- **Сервер**: ожидает подключения клиентов, принимает от них пакеты, анализирует и выводит в консоль содержимое заголовка IPv6 и заголовка "Опции назначения", а затем отправляет полученные данные обратно клиенту (эхо-сервер).
- **Клиент**: подключается к указанному IPv6-адресу сервера, отправляет ему специально сформированные пакеты с заголовком "Опции назначения" и выводит ответы от сервера.

Программа использует многопоточность (`pthreads`) для одновременной обработки нескольких клиентов на стороне сервера и для асинхронного приема сообщений на стороне клиента.

## 2. Структура файла

Код логически разделен на несколько частей:
1.  **Заголовочные файлы**: подключения необходимых библиотек (`sys/socket`, `netinet/in`, `pthread`, и др.).
2.  **Константы**: `PORT`, `MAX_CLIENTS`, `BUFFER_SIZE`.
3.  **Структуры данных**:
    - `struct ipv6_header`: для представления стандартного заголовка IPv6.
    - `struct dest_options`: для пользовательского заголовка "Опции назначения".
    - `client_t`: для хранения информации о подключенном клиенте.
4.  **Глобальные переменные**: мьютекс для синхронизации доступа к списку клиентов, массив клиентов и флаги состояния сервера.
5.  **Прототипы функций**: объявления всех функций, используемых в программе.
6.  **Серверная часть**: функции, отвечающие за логику работы сервера (`start_server`, `setup_server_socket`, `accept_connections`, `handle_client`).
7.  **Клиентская часть**: функции для работы клиента (`start_client`, `connect_to_ipv6_server`, `send_ipv6_packet`, `receive_messages`).
8.  **Утилиты**: вспомогательные функции для вывода информации из заголовков (`print_ipv6_header`, `print_dest_options`) и для преобразования порядка байт (`htonll`, `ntohll`).
9.  **Основная функция `main`**: точка входа, где пользователь выбирает режим работы (сервер или клиент).

## 3. Ключевые структуры данных

### `struct ipv6_header`
Эта структура описывает 40-байтный заголовок пакета IPv6. Она использует `union` для двух целей:
- `fields`: структурированный доступ к отдельным полям заголовка (версия, класс трафика, метка потока и т.д.). Для корректной работы на системах с разным порядком байт (little-endian/big-endian) используются директивы препроцессора `#if __BYTE_ORDER == __LITTLE_ENDIAN`.
- `raw`: доступ к заголовку как к сырому массиву байт.

### `struct dest_options`
Структура, описывающая пользовательский расширенный заголовок "Опции назначения". В данном примере она используется для передачи 64-битного значения `ram_address`.

- `next_header`: идентификатор следующего заголовка (в данном случае TCP, код 6).
- `hdr_ext_len`: длина этого заголовка.
- `opt_type`: тип опции. `0xC2` указывает на то, что узел, не распознавший эту опцию, должен отбросить пакет и отправить в ответ сообщение ICMP.
- `opt_len`: длина данных опции.
- `ram_address`: 64-битное поле с данными.

## 4. Логика работы

### Сервер
1.  **`start_server()`**: инициализирует массив клиентов и вызывает `setup_server_socket()`.
2.  **`setup_server_socket()`**:
    - Создает сокет `AF_INET6` (IPv6) типа `SOCK_STREAM` (TCP).
    - Устанавливает опции сокета: `SO_REUSEADDR` (позволяет немедленно перезапускать сервер) и `IPV6_V6ONLY` (запрещает принимать подключения с IPv4-адресов).
    - Привязывает сокет к адресу `in6addr_any` (любой сетевой интерфейс) и порту `PORT`.
    - Переводит сокет в режим прослушивания с помощью `listen()`.
3.  **`accept_connections()`**: в бесконечном цикле ожидает новые подключения с помощью `accept()`. Для каждого нового подключения создается отдельный поток, который выполняет функцию `handle_client()`.
4.  **`handle_client()`**:
    - В цикле принимает данные от клиента (`recv`).
    - Интерпретирует полученный буфер данных как `struct ipv6_header`.
    - Если это действительно IPv6 пакет (версия 6), вызывает `print_ipv6_header()` для вывода информации о заголовке.
    - Проверяет поле `next_header`. Если это заголовок "Опции назначения" (код 60), то он интерпретирует следующую часть буфера как `struct dest_options` и вызывает `print_dest_options()`.
    - Отправляет полученные данные обратно клиенту (`send`).

### Клиент
1.  **`start_client()`**:
    - Вызывает `connect_to_ipv6_server()` для установки соединения.
    - Создает отдельный поток для выполнения функции `receive_messages`, которая будет асинхронно принимать и выводить сообщения от сервера.
    - В основном потоке читает ввод пользователя из консоли.
2.  **`connect_to_ipv6_server()`**:
    - Создает сокет IPv6.
    - Обрабатывает адреса, содержащие ID зоны (например, `fe80::1234%eth0`), что необходимо для link-local адресов.
    - Устанавливает соединение с сервером с помощью `connect()`.
3.  **`send_ipv6_packet()`**:
    - **Ключевая функция клиента.** Она не просто отправляет данные, а вручную формирует полный пакет.
    - Заполняет структуры `ipv6_header` и `dest_options`.
    - Копирует заголовок IPv6, заголовок опций и пользовательское сообщение в один буфер.
    - Отправляет этот собранный пакет на сервер с помощью `send()`.
4.  **`receive_messages()`**: в цикле ожидает данные от сервера и выводит их в консоль.

## 5. Сборка и запуск

### Сборка
Для компиляции файла используйте GCC, не забыв подключить библиотеку для работы с потоками:
```bash
gcc ipv6_sockets.c -o ipv6_app -lpthread
```

### Запуск
1.  **Запустите сервер:**
    ```bash
    ./ipv6_app
    Выберите режим:
    1. Сервер IPv6
    2. Клиент IPv6
    > 1
    Сервер IPv6 запущен на порту 8080
    Ожидание IPv6 подключений...
    ```

2.  **В другом терминале запустите клиент:**
    - Для подключения к серверу на той же машине (loopback):
    ```bash
    ./ipv6_app
    Выберите режим:
    ...
    > 2
    Введите IPv6 адрес сервера: ::1
    ```
    - Для подключения к link-local адресу (замените `eth0` на имя вашего сетевого интерфейса):
    ```bash
    # Узнать имя интерфейса можно командой `ip a` или `ifconfig`
    ./ipv6_app
    > 2
    Введите IPv6 адрес сервера: fe80::a00:27ff:fe4d:5e1a%eth0
    ```

После подключения клиента вводите сообщения в его консоли. В консоли сервера вы увидите детальный разбор отправленных клиентом пакетов.

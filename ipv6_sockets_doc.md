# Документация для ipv6_sockets.c

## 1. Введение в IPv6

Прежде чем погружаться в код, важно понять основы интернет-протокола версии 6 (IPv6), так как эта программа является практической демонстрацией работы с ним.

### Что такое IPv6?
IPv6 — это следующая версия интернет-протокола, разработанная для замены IPv4. Основная причина его создания — исчерпание доступных IPv4-адресов из-за стремительного роста количества устройств, подключенных к интернету.

### Ключевые отличия и преимущества:
- **Огромное адресное пространство**: IPv6 использует 128-битные адреса (в отличие от 32-битных в IPv4), что предоставляет практически неисчерпаемый запас уникальных адресов.
- **Формат адреса**: Адреса записываются в виде восьми 16-битных блоков в шестнадцатеричной системе, разделенных двоеточиями (например, `2001:0db8:85a3:0000:0000:8a2e:0370:7334`). Для краткости ведущие нули в блоках можно опускать, а одну последовательность нулевых блоков можно заменить двойным двоеточием `::` (например, `fe80::1`).
- **Упрощенный заголовок**: Заголовок пакета IPv6 имеет фиксированный размер (40 байт) и более простую структуру, что ускоряет его обработку маршрутизаторами.
- **Расширенные заголовки (Extension Headers)**: Дополнительные опции, которые в IPv4 были частью основного заголовка, в IPv6 вынесены в необязательные "расширенные заголовки". Это делает основной заголовок легким, а протокол — гибким. **Данная программа как раз демонстрирует создание и использование такого заголовка.**
- **Link-Local адреса**: IPv6 вводит стандартные локальные адреса (`fe80::/10`), которые автоматически присваиваются сетевым интерфейсам и используются для связи в пределах одного физического сегмента сети (например, в домашней локальной сети). Для их использования необходимо указывать *зону* или *интерфейс* (например, `fe80::1234%eth0`).

## 2. Общее описание программы

Файл `ipv6_sockets.c` — это клиент-серверное приложение, демонстрирующее основы сетевого программирования с использованием сокетов TCP через IPv6.

**Основная цель программы** — показать, как вручную создать IPv6-пакет, добавить в него расширенный заголовок **"Опции назначения" (Destination Options)**, отправить его по сети и разобрать на принимающей стороне.

Приложение работает в двух режимах:
- **Сервер**: Принимает подключения от клиентов. Для каждого клиента создается отдельный поток. Сервер не просто читает данные, а анализирует полученный сырой пакет, выводит в консоль содержимое стандартного заголовка IPv6 и кастомного заголовка "Опции назначения", а также полезную нагрузку (сообщение).
- **Клиент**: Подключается к серверу по указанному IPv6-адресу. Пользователь вводит сообщение, а клиент формирует полный IPv6-пакет (заголовок + опции + сообщение) и отправляет его на сервер.

## 3. Ключевые структуры данных

### `struct ipv6_header`
Описывает стандартный 40-байтный заголовок пакета IPv6.
- `version`: Версия протокола (всегда 6).
- `traffic_class`, `flow_label`: Поля для управления качеством обслуживания (QoS).
- `payload_len`: Размер полезной нагрузки (включая расширенные заголовки).
- `next_header`: **Важнейшее поле**. Указывает, какой заголовок идет следующим. Это может быть TCP (код 6), UDP (код 17) или один из расширенных заголовков (в нашей программе — "Опции назначения", код 60).
- `hop_limit`: Аналог TTL в IPv4, счетчик максимального числа переходов.
- `src_addr`, `dst_addr`: 128-битные адреса отправителя и получателя.

### `struct dest_options`
Описывает наш кастомный расширенный заголовок "Опции назначения".
- `next_header`: Указывает, что после этого заголовка идет заголовок TCP (код 6).
- `hdr_ext_len`: Длина этого заголовка в 8-байтных блоках.
- `opt_type`, `opt_len`: Тип и длина самой опции.
- `ram_address`: Поле с 64-битными данными, которые мы передаем в этой опции.

### `client_t`
Простая структура для хранения данных о подключенном клиенте: его сокет, адрес и идентификатор потока.

### `struct sockaddr_in6`
Стандартная системная структура для хранения информации об IPv6-адресе, включая семейство адресов, порт, а также `sin6_scope_id` для указания индекса сетевого интерфейса при работе с link-local адресами.

## 4. Логика работы и ключевые функции

### Серверная часть
1.  **`start_server()` -> `setup_server_socket()`**:
    - Создается сокет `socket(AF_INET6, SOCK_STREAM, 0)`.
    - Устанавливается опция `IPV6_V6ONLY`, чтобы сокет принимал только IPv6-соединения.
    - Сокет привязывается (`bind`) ко всем доступным интерфейсам (`in6addr_any`) и переводится в режим прослушивания (`listen`).

2.  **`accept_connections()`**: В цикле ожидает подключения (`accept`). Каждое новое соединение обрабатывается в отдельном потоке, который запускает функцию `handle_client`.

3.  **`handle_client()`**:
    - Получает сырые данные от клиента с помощью `recv`.
    - **Ключевой момент**: Указатель на буфер с данными приводится к типу `(struct ipv6_header *)`. Это позволяет интерпретировать первые 40 байт как заголовок IPv6.
    - Вызывается `print_ipv6_header()` для вывода полей заголовка.
    - Проверяется поле `next_header`. Если оно равно 60 ("Опции назначения"), указатель смещается на 40 байт вперед и приводится к типу `(struct dest_options *)` для анализа заголовка опций.
    - Оставшаяся часть буфера интерпретируется как полезная нагрузка (сообщение).

### Клиентская часть
1.  **`start_client()` -> `connect_to_ipv6_server()`**:
    - Создает сокет и устанавливает соединение (`connect`).
    - **Важная деталь**: Функция умеет парсить адреса с указанием интерфейса (например, `fe80::...%eth0`). Она извлекает имя интерфейса, получает его системный индекс с помощью `if_nametoindex()` и записывает в поле `sin6_scope_id` структуры `sockaddr_in6`. Это обязательно для работы с link-local адресами.

2.  **`send_ipv6_packet()`**:
    - **Самая важная функция клиента.** Она не просто отправляет текст, а **вручную конструирует пакет**:
    1.  Заполняются поля структуры `ipv6_header`. В `next_header` ставится `60`.
    2.  Заполняются поля структуры `dest_options`. В `next_header` ставится `6`.
    3.  Создается буфер, в который последовательно копируются (`memcpy`) байты из `ipv6_header`, затем из `dest_options`, и в конце — текстовое сообщение.
    4.  Весь этот собранный "пирог" отправляется на сервер одним вызовом `send()`.

## 5. Сборка и запуск

### Сборка
Для компиляции используйте GCC, указав флаг `-lpthread` для подключения библиотеки потоков:
```bash
gcc ipv6_sockets.c -o ipv6_app -lpthread
```

### Запуск
1.  **Запустите сервер в одном терминале:**
    ```bash
    ./ipv6_app
    Выберите режим:
    1. Сервер IPv6
    2. Клиент IPv6
    > 1
    Link-local IPv6 addresses:
    Interface: eth0	Address: fe80::a00:27ff:fe4d:5e1a
    ...
    Сервер IPv6 запущен на порту 8080
    Ожидание IPv6 подключений...
    ```

2.  **Запустите клиент в другом терминале:**
    - Для подключения к серверу на той же машине (loopback-адрес):
    ```bash
    ./ipv6_app
    > 2
    Введите IPv6 адрес сервера: ::1
    ```
    - Для подключения, используя link-local адрес (возьмите его из вывода сервера, заменив `eth0` на имя вашего интерфейса):
    ```bash
    ./ipv6_app
    > 2
    Введите IPv6 адрес сервера: fe80::a00:27ff:fe4d:5e1a%eth0
    ```

3.  **Тестирование**:
    - Введите сообщение в консоли клиента и нажмите Enter.
    - В консоли сервера вы увидите полный разбор пакета: заголовок IPv6, заголовок опций и само сообщение.